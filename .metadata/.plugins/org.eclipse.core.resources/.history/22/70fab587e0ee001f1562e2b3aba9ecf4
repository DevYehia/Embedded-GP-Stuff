#include "Bootloader.h"

/* Global pointer to BL_Data received from UDS */
static BL_Data *g_BLData = NULL;


extern BL_Data* UDS_BL_Receive(void);



volatile uint32_t calculatedCRC32;

volatile uint32_t pflash_pfcr1, pflash_pfcr2;

status_t Bootloader_Init(void)
{
    DisableFlashControllerCache(FLASH_PFCR1, FLASH_FMC_BFEN_MASK, &pflash_pfcr1); //should call the function directly without any parameters
    DisableFlashControllerCache(FLASH_PFCR2, FLASH_FMC_BFEN_MASK, &pflash_pfcr2);

    /* Receive BL_Data from UDS and store it globally */
    g_BLData = UDS_Receive();
    if (g_BLData == NULL)
    {
        return STATUS_ERROR;
    }

    /* Initialize the flash module */
    return BootloaderFlash_Init();
}

status_t Bootloader_Erase_Memory(void)
{
    if (g_BLData == NULL)
    {
        return STATUS_ERROR;
    }

    ret = BootloaderFlash_Unlock();
    	if (ret != STATUS_SUCCESS){
    		return ret;
    	}

    /* Use UDS data: mem_start_address and total_size to erase flash */
    ret =  BootloaderFlash_Erase(g_BLData->mem_start_address, g_BLData->total_size);

	if (ret != STATUS_SUCCESS){
		return ret;
	}

	return BootloaderFlash_VerifyBlank(g_BLData->mem_start_address, g_BLData->total_size);
}

status_t Bootloader_Program(void)
{
    if (g_BLData == NULL)
    {
        return STATUS_ERROR;
    }

   ret = BootloaderFlash_Program(g_BLData->mem_start_address, g_BLData->total_size, g_BLData->data);

   if (ret != STATUS_SUCCESS)
   {
	   return ret;
   }
   ret = BootloaderFlash_ProgramVerify(g_BLData->mem_start_address, g_BLData->total_size, g_BLData->data);
	while (ret == STATUS_FLASH_INPROGRESS){
		ret = BootloaderFlash_ProgramVerify(g_BLData->mem_start_address, g_BLData->total_size, g_BLData->data);
	}
	return ret;
}

status_t Bootloader_CheckMemory(void)
{
    if (g_BLData == NULL)
    {
        return STATUS_ERROR;
    }

    BootloaderFlash_InitCRC();
    /* Compute the CRC32 over the flash area specified by mem_start_address and total_size */
    uint32_t computed_crc = BootloaderFlash_CalculateCRC32(g_BLData->mem_start_address, g_BLData->total_size);

    /* Restore flash controller cache */
    RestoreFlashControllerCache(FLASH_PFCR1, pflash_pfcr1);
    RestoreFlashControllerCache(FLASH_PFCR2, pflash_pfcr2);

    /* Compare the computed CRC with the expected CRC provided in the BL_Data structure */
    if (computed_crc == g_BLData->CRC_Field)
    {
        return STATUS_SUCCESS;
    }
    else
    {
        return STATUS_ERROR;
    }
}

/* Define the array of handler function pointers.
 * Order in the array is important and should match the service IDs used in UDS.
 * For example:
 *   index 0 -> Erase
 *   index 1 -> Program
 *   index 2 -> Memory Check
 */
BootloaderHandler_t g_BootloaderHandlers[] = {
	Bootloader_Erase_Memory,
    Bootloader_Program,
	Bootloader_CheckMemory
};
